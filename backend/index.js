require('dotenv').config()
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const prismaService = require('./services/prismaService');

// Import du nouveau syst√®me d'archivage
const { startProgramCleanupCron } = require('./utils/chatCleanup');

// Import des routes existantes
const kinesRoutes = require('./routes/kines');
const patientsRoutes = require('./routes/patients');
const programmeRoutes = require('./routes/programmes');
const programmeAdminRoutes = require('./routes/programmeAdmin');
const exerciceRoutes = require('./routes/exercices');
const testOpenAIRoutes = require('./routes/testOpenAI');
const patientChatRoutes = require('./routes/patientChat');
const chatKineRoutes = require('./routes/chatKine'); // Route existante am√©lior√©e

// NOUVELLES ROUTES VECTORIELLES
const documentsRoutes = require('./routes/documents');

const app = express();
const PORT = process.env.PORT || 8080;

// Middleware - Augment√© pour les PDFs
app.use(cors());
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));

// ========== ROUTES DE TEST - POUR DEBUG ==========

// Health check simple
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    service: 'KineAI Backend with Vector DB',
    port: PORT,
    features: [
      'Patient Chat',
      'Programme Management', 
      'Auto Archive System',
      'Kin√© Personal AI Assistant Enhanced',
      'PDF Upload & Vector Search'
    ]
  });
});

// Test connexion base de donn√©es
app.get('/api/test-db', async (req, res) => {
  try {
    const prisma = prismaService.getInstance();
    
    const kineCount = await prisma.kine.count();
    
    res.json({
      message: 'Database connection successful',
      timestamp: new Date().toISOString(),
      kineCount: kineCount,
      database: 'PostgreSQL + Prisma + Supabase Vector'
    });
  } catch (error) {
    console.error('Database connection error:', error);
    res.status(500).json({
      error: 'Database connection failed',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Test variables d'environnement
app.get('/api/test-env', (req, res) => {
  res.json({
    message: 'Environment check',
    timestamp: new Date().toISOString(),
    env: {
      NODE_ENV: process.env.NODE_ENV,
      PORT: process.env.PORT,
      hasFirebaseConfig: !!process.env.FIREBASE_PROJECT_ID,
      hasOpenAI: !!process.env.OPENAI_API_KEY,
      hasJWT: !!process.env.JWT_SECRET_PATIENT,
      hasDatabaseURL: !!process.env.DATABASE_URL,
      frontendURL: process.env.FRONTEND_URL,
      hasSupabase: !!(process.env.SUPABASE_URL && process.env.SUPABASE_API_KEY)
    }
  });
});

// NOUVEAU : Test de la base vectorielle
app.get('/api/test-vector', async (req, res) => {
  try {
    // Test de connexion Supabase seulement si les services sont disponibles
    let vectorStatus = { connected: false, error: 'Services non disponibles' };
    
    try {
      const { supabase } = require('./services/supabaseClient');
      
      const { count, error } = await supabase
        .from('documents_kine')
        .select('*', { count: 'exact', head: true });
      
      if (error) throw error;
      
      vectorStatus = {
        connected: true,
        url: process.env.SUPABASE_URL,
        documentsCount: count || 0
      };
    } catch (serviceError) {
      vectorStatus = {
        connected: false,
        error: serviceError.message
      };
    }

    res.json({
      message: vectorStatus.connected ? 'Vector database connection successful' : 'Vector database connection failed',
      timestamp: new Date().toISOString(),
      supabase: vectorStatus
    });
    
  } catch (error) {
    res.status(500).json({
      error: 'Vector database test failed',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Debug base de donn√©es
app.get('/api/debug-db', async (req, res) => {
  try {
    const prisma = prismaService.getInstance();
    
    const dbInfo = await prisma.$queryRaw`SELECT current_database(), current_schema(), version()`;
    const tables = await prisma.$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
    `;
    
    res.json({
      database: dbInfo,
      tables: tables,
      tableCount: tables.length,
      databaseUrl: process.env.DATABASE_URL?.replace(/:[^:@]*@/, ':***@'),
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// ========== NOUVELLES ROUTES DEBUG PRISMA ==========

// Route pour diagnostiquer les imports multiples de Prisma
app.get('/debug/prisma-imports', (req, res) => {
  const stats = prismaService.getConnectionStats();
  
  // Lister tous les modules charg√©s qui contiennent "prisma"
  const prismaModules = Object.keys(require.cache)
    .filter(path => path.includes('prisma') || path.includes('Prisma'))
    .map(path => ({
      path: path.replace(process.cwd(), ''), // Chemin relatif
      loaded: !!require.cache[path],
      loadTime: require.cache[path]?.loaded ? 'loaded' : 'loading'
    }));

  // Compter les services prisma charg√©s
  const prismaServiceModules = Object.keys(require.cache)
    .filter(path => path.includes('prismaService'))
    .map(path => path.replace(process.cwd(), ''));

  res.json({
    stats,
    prismaModules: prismaModules.slice(0, 10), // Limite √† 10 pour lisibilit√©
    prismaServiceModules,
    moduleLoadOrder: prismaModules.length,
    warning: stats.creationCount > 1 ? '‚ö†Ô∏è MULTIPLE INSTANCES DETECTED!' : '‚úÖ OK - Single instance',
    recommendation: stats.creationCount > 1 ? 
      'V√©rifiez vos imports: utilisez toujours le m√™me chemin relatif' : 
      'Configuration correcte'
  });
});

// Route pour surveiller les connexions DB en temps r√©el
app.get('/debug/connections', async (req, res) => {
  try {
    const stats = prismaService.getConnectionStats();
    const health = await prismaService.healthCheck();
    
    res.json({
      prisma: stats,
      health,
      server: {
        uptime: Math.round(process.uptime()) + 's',
        pid: process.pid,
        memory: {
          used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024) + 'MB',
          total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024) + 'MB'
        }
      },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Route pour forcer le nettoyage des connexions
app.post('/debug/cleanup-connections', async (req, res) => {
  try {
    console.log('üßπ Nettoyage forc√© des connexions demand√© via API');
    await prismaService.forceDisconnect();
    
    // Petit d√©lai pour laisser les connexions se fermer
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const newStats = prismaService.getConnectionStats();
    
    res.json({ 
      success: true, 
      message: 'Connexions nettoy√©es et r√©initialis√©es',
      before: 'connexions ferm√©es',
      after: newStats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Route pour lister tous les imports de votre projet
app.get('/debug/all-imports', (req, res) => {
  const allModules = Object.keys(require.cache)
    .filter(path => path.includes(process.cwd())) // Seulement votre projet
    .map(path => path.replace(process.cwd(), ''))
    .sort();

  const prismaRelated = allModules.filter(path => 
    path.includes('prisma') || 
    path.includes('database') || 
    path.includes('db')
  );

  res.json({
    totalModules: allModules.length,
    prismaRelated,
    warning: prismaRelated.length > 3 ? 
      '‚ö†Ô∏è Beaucoup de modules Prisma charg√©s' : 
      '‚úÖ Imports normaux'
  });
});

// ========== ROUTES PRINCIPALES ==========

// Routes existantes
app.use('/kine', kinesRoutes);
app.use('/patients', patientsRoutes);
app.use('/programmes', programmeRoutes);
app.use('/admin/programmes', programmeAdminRoutes);
app.use('/exercices', exerciceRoutes);
app.use('/api/test', testOpenAIRoutes);
app.use('/api/patient', patientChatRoutes);
app.use('/api/chat/kine', chatKineRoutes); // Route existante avec nouvelles fonctionnalit√©s

// NOUVELLE ROUTE VECTORIELLE
app.use('/api/documents', documentsRoutes);

// Routes de test pour le syst√®me d'archivage
app.get('/test-archive-finished', async (req, res) => {
  const { manualArchiveTest } = require('./utils/chatCleanup');
  try {
    const result = await manualArchiveTest();
    res.json({ success: true, result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/test-cleanup-archived', async (req, res) => {
  const { manualCleanupTest } = require('./utils/chatCleanup');
  try {
    const result = await manualCleanupTest();
    res.json({ success: true, result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Route racine mise √† jour
app.get('/', (req, res) => {
  res.json({
    message: 'Bienvenue sur l API KineAI - Base Vectorielle Supabase Int√©gr√©e',
    timestamp: new Date().toISOString(),
    version: '2.2',
    status: 'running',
    features: [
      'Patient Chat',
      'Programme Management', 
      'Auto Archive System',
      'Kin√© Personal AI Assistant Enhanced', 
      'PDF Upload & Vector Search',
      'Semantic Knowledge Base'
    ],
    endpoints: {
      chat: '/api/chat/kine/message',
      chatEnhanced: '/api/chat/kine/message-enhanced',
      documents: '/api/documents',
      upload: '/api/documents/upload',
      search: '/api/documents/search',
      vectorTest: '/api/test-vector',
      // NOUVEAUX ENDPOINTS DEBUG
      debugPrisma: '/debug/prisma-imports',
      debugConnections: '/debug/connections',
      cleanupConnections: '/debug/cleanup-connections [POST]'
    }
  });
});

// D√©marrage du syst√®me d'archivage automatique
startProgramCleanupCron();

// Gestion gracieuse de l'arr√™t
process.on('SIGINT', async () => {
  console.log('üõë Arr√™t du serveur...');
  await prismaService.disconnect();
  process.exit(0);
});

// D√©marrage du serveur
app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ KineAI Backend running on port ${PORT}`);
  console.log(`üì± Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üîó Health check: http://localhost:${PORT}/health`);
  console.log(`ü§ñ Chat Kin√©: /api/chat/kine/message`);
  console.log(`ü§ñ Chat Enhanced: /api/chat/kine/message-enhanced`);
  console.log(`üìÑ Documents API: /api/documents`);
  console.log(`üìä Vector Test: /api/test-vector`);
  console.log(`üîç Debug Prisma: /debug/prisma-imports`);
  console.log(`üìä Debug Connections: /debug/connections`);
});